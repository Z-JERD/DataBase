#######################################行锁与表锁################################################
"""
简述：

    行锁，锁的是表中对应的行，只限制当前行的读写。
    表锁，锁的是整张表，限制的是整张表的数据读写。

比较：

    行锁，计算机资源开销大，加锁慢；会出现死锁；锁定粒度最小，锁冲突的概率最低，并发度最高，性能高。
    表锁，计算机资源开销小，加锁快；不会出现死锁；锁定粒度大，锁冲突的概率最高，并发度最低，性能低。

两种行锁的特点:

    共享锁:
    
        A 对数据 B 加了 共享锁，A能读取和修改数据B，C 等其它只能读取数据B，但是不能修改。直至A释放了B的锁。
    
    排他锁:
    
        A  对数据 B 加了 排他锁，A能读取和修改数据B，C 等其它不能再对数据B加其它的锁。直观体验是不能修改，不能使用含有加锁动作的select读取。

两种行锁的加锁方式:

    要注意的是：
    
        行锁的实现SQL语句中必须要有索引的限制条件，例如含有 where id=xxx 这类语句。
        行锁的实现SQL语句没有索引限制条件会变成表锁
        InnoDB引擎 默认的修改数据类SQL语句，update,delete,insert等，都会自动给涉及到的数据加上排他锁。
    
    共享锁:
        select 的添加可以使用满足格式：select ... where 索引限制 lock in share mode 的语句。例如“select name from lgh_user where id = 1 lock in share model” 此时 id 是索引。
    排他锁:
        满足格式：select ... where 索引限制 for update 的语句
    锁的释放:
        非事务(Transaction) 中，语句执行完毕，便释放锁。
        行锁在事务 (Transaction) 中，只有等到当前的事务Transaction 进行了 commit 或 roll back，锁才能释放。

"""
