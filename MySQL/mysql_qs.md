## 为什么一定要设一个主键？
    不设主键的情况下，innodb也会帮你生成一个隐藏列，作为自增主键。所以啦，反正都要生成一个主键，那你还不如自己指定一个主键，
    在有些情况下，就能显式的用上主键索引，提高查询效率！
    
## 主键是用自增还是UUID
    用自增插入性能好！如果主键是自增的，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，
    当一页写满，就会自动开辟一个新的页。如果不是自增主键，那么可能会在中间插入，就会引发页的分裂，产生很多表碎片
    
### 自增主键达到最大值了，用完了怎么办
    Int整型,无符号整型为例，存储范围约43亿,一旦自增id达到最大值，此时数据继续插入是会报一个主键冲突异常
    解决方法: 将Int类型改为BigInt类型
    
    专业做法：分库分表
        表中真实的数据ID，肯定会出现一些意外，ID不一定是连续的，自增主键id的数据范围为0～2147483648，也就是单表21亿条数据！
        考虑id会出现断续，真实数据顶多18亿条吧。还不分库分表？一旦分库分表了，就不能依赖于每个表的自增ID来全局唯一标识这些数据了。
        此时，我们就需要提供一 个全局唯一的ID号生成策略来支持分库分表的环境
    
### 在线上怎么修改列的数据类型的？
    
    由于mysql在线ddl(加字段、加索引等修改表结构之类的操作）过程如下：
        A.对表加锁(加了个排它锁，这个时候其他用户只能读表的数据,不能写)
        B.复制原表物理结构
        C.修改表的物理结构
        D.把原表数据导入中间表中，数据同步完后，锁定中间表，并删除原表
        E.rename中间表为原表
        F.刷新数据字典，并释放锁
        
       
    在这个过程中会锁表。造成当前操作的表无法写入数据，影响用户使用。由于需要复制原表的数据到中间表，所以表的数据量越大，等待的时候越长，卡死在那里(用户被拒绝执行update和insert操作,表现就是延迟了一直在等待)
    平时进行修改表的结构，更改字段，新增字段，更改字段名称一般都是通过ALTER TABLE  TABLENAE 语法进行修改的。
    对于测试库，在线小表或者并发访问不是很大的情况是OK。但是如果是在线大表。那就很麻烦。由于表数据量大，复制表需要比较长的时间，
    在这个时间段里面，表是被加了锁的(写锁)，加写锁时其他用户只能select表不能update、insert表。表数据量越大，耗时越长
        
        
    1. mysql5.6+提供的在线修改功能
        mysql> ALTER TABLE table_name CHANGE old_field_name new_field_name field_type;
        在5.6+开始，mysql支持在线修改数据库表，在修改表的过程中，对绝大部分操作，原表可读，也可以写
        对于修改列的数据类型这种操作，ALTER这样的语句在线修改表数据结构，会导致这张表无法进行更新类操作(DELETE、UPDATE、DELETE)。
    2.借助第三方工具
        在执行ALTER操作的时候，表不会阻塞！比较出名的有两个
        pt-online-schema-change，简称pt-osc
        GitHub正式宣布以开源的方式发布的工具，名为gh-ost
    
        工作原理：以pt-osc为例，它的原理如下

            1、创建一个新的表，表结构为修改后的数据表，用于从源数据表向新表中导入数据。
            
            2、创建触发器，用于记录从拷贝数据开始之后，对源数据表继续进行数据修改的操作记录下来，用于数据拷贝结束后，执行这些操作，保证数据不会丢失。
            
            3、拷贝数据，从源数据表中拷贝数据到新表中。
            
            4、rename源数据表为old表，把新表rename为源表名，并将old表删除。
            
            5、删除触发器
            
        BUG：
            如果表里有触发器和外键，这两个工具是不行
            
    3.改从库表结构，然后主从切换
        mysql架构一般是读写分离架构，从机是用来读的。我们直接在从库上进行表结构修改，不会阻塞从库的读操作。
        改完之后，进行主从切换即可。唯一需要注意的是，主从切换过程中可能会有数据丢失的情况！
        
## 主键为什么不推荐有业务含义?
    (1)因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。主键一旦发生变更，
       该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。
    (2)带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面插入数据的主键一定比前面的数据大。
       如果出现了，后面插入数据的主键比前面的小，就有可能引发页分裂，产生空间碎片
 

## 表示枚举的字段为什么不用enum类型      
     在工作中表示枚举的字段，一般用tinyint类型
     ENUM类型的ORDER BY操作效率低，后期维护不方便
     

## 货币字段用什么类型?
    如果货币单位是分，可以用Int类型。如果坚持用元，用Decimal。
    float和double是以二进制存储的，所以有一定的误差
    
## 时间字段用什么类型?
    1.timestamp
        该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。
        2038年以后的时间，是无法用timestamp类型存储的。 但是它有一个优势，timestamp类型是带有时区信息的。
        一旦你系统中的时区发生改变，例如你修改了时区
        
        SET TIME_ZONE = "america/new_york";
        你会发现，项目中的该字段的值自己会发生变更。这个特性用来做一些国际化大项目，跨时区的应用时，特别注意！
    2.datetime
        datetime储存占用8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显然，存储时间范围更大。
        但是它坑的地方在于，他存储的是时间绝对值，不带有时区信息。如果你改变数据库的时区，该项的值不会自己发生变更！
        
## 为什么不直接存储图片、音频、视频等大容量内容?
    在实际应用中，都是用HDFS来存储文件。然后mysql中，只存文件的存放路径。mysql中有两个字段类型被用来设计存放大容量文件，
    也就是text和blob类型。在生产中，基本不用这两个类型！
    
## 字段为什么要定义为NOT NULL
    Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。
    可空列被索引后，每条记录都需要一个额外的字节

# 事务相关
## Mysql怎么保证一致性的？ 
    1.从数据库层面
        数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、
        I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。
        例如，原子性无法保证，显然一致性也无法保证。但是，如果你在事务里故意写出违反约束的代码，一致性还是无法保证的。
        例如，你在转账的例子中，你的代码里故意不给B账户加钱，那一致性还是无法保证。
    
    2.从应用层角度考虑。从应用层面，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据！
    

## Mysql怎么保证原子性的？
    利用Innodb的undo log。 undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，
    他需要记录你要回滚的相应日志信息。 例如 
    (1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据  
    (2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作 
    (3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作
    undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。
    
## Mysql怎么保证持久性的？
    利用Innodb的redo log。Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失
    采用redo log当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当事务提交的时候，
    会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，
    会将redo log中的内容恢复到数据库中，再根据undo log和binlog内容决定回滚数据还是提交数据。
    
    
## Mysql怎么保证隔离性的？
    利用的是锁和MVCC机制
    MVCC,即多版本并发控制(Multi Version Concurrency Control),一个行记录数据有多个版本对快照数据，
    这些快照数据在undo log中。 如果一个事务读取的行正在做DELELE或者UPDATE操作，读取操作不会等行上的锁释放，而是读取该行的快照版本
    
 
## 为什么不推荐使用外键约束
    很多人在工作中确实也不会使用外键。包括在阿里的JAVA规范中也有下面这一条
    【强制】不得使用外键与级联，一切外键概念必须在应用层解决。 
    
    但是呢，询问他们原因，大多是这么回答的:
        每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦,测试数据极为不方便。
        
    1.性能问题
        假设一张表名为user_tb。那么这张表里有两个外键字段，指向两张表。那么，每次往user_tb表里插入数据，
        就必须往两个外键对应的表里查询是否有对应数据。如果交由程序控制，这种查询过程就可以控制在我们手里，
        可以省略一些不必要的查询过程。但是如果由数据库控制，则是必须要去这两张表里判断。
    
    2.并发问题
        在使用外键的情况下，每次修改数据都需要去另外一个表检查数据,需要获取额外的锁。若是在高并发大流量事务场景，使用外键更容易造成死锁。
        
    
    3.技术问题
        使用外键，其实将应用程序应该执行的判断逻辑转移到了数据库上。那么这意味着一点，数据库的性能开销变大了，
        相反的，如果该约束逻辑在应用程序中，发现应用服务器性能不够，可以加机器，做水平扩展。如果是在数据库服务器上，
        数据库服务器会成为性能瓶颈，做水平扩展比较困难




